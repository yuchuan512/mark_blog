title: java面试问题总结
date: 2016-04-16 12:09:00
categories: [java,面试]
tags: [java,面试]
---
#### java锁类型
 - 自旋锁，为解决由用户态和内核态的频繁切换以及线程上下文切换开销比较大引入自旋锁。问题：ABA,单核无效。解决：AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。
 - 可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。
 - 阻塞锁，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpark()。阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。

#### java内存模型
(主内存、工作内存、交互、八种操作lock,unlock、重排序三类)
1. 从主存复制变量到当前工作内存 (read and load)
2. 执行代码，改变共享变量 (use and assign)
3. 用工作内存数据刷新主存相关的内容 (store and write)

#### 进程线程管程区别
 - 进程 ：一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间
 - 线程 ：线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。

#### 死锁
产生死锁的条件：互斥、请求与保持、不剥夺条件、循环等待条件
*解除与预防*
1.采用资源静态分配策略，破坏”部分分配”条件
2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件
3.采用资源有序分配法，破坏环路条件

#### 聚集索引和非聚集索引
1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。
2.一个表只能包含一个聚集索引，可以有多个非聚集索引
3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻
4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。

#### 单例模式
1.为避免其他程序创建该类对象，将构造函数私有化
2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象
3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式
比如API中的Runtime类就是单例设计模式。
```
class Singleton{
	private static Singleton instance;
	private static byte[] lock = new byte[1];
	private Singleton{ }
	public static Singleton getInstance(){
		if(instance == null){
			synchronized(lock){
				if(instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```


#### final关键字
1. final修饰变量：final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。
2. final修饰的方法：final修饰的方法不能被子类重写
3. final修饰的类：final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。

#### fail-fast && fail-safe
Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：
注意到modCount声明为volatile，保证线程之间修改的可见性。

#### 堆内存
 * 新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。
 * 老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。
 * 永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。

#### 垃圾收集算法
 * 标记-清除算法
首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
 * 复制算法
将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）
 * 标记-整理算法
把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。
 * 分代收集算法
根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。

#### transient
transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。

#### 重写equals方法
1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。
2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。
3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。
4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。
5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。

#### 重写hashCode的意义
1. 在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。
2. 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
3. 如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
4. 如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。

#### JVM 运行时数据区 (JVM Runtime Area)
6个区域：
1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。
2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈
帧在虚拟机栈中从入栈到出栈的过程。
3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。
4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。
Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。
JVM将Heap分为两块：新生代New Generation和旧生代Old Generation
** 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因 **
5、方法区
方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。
方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。
6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。

#### 线程池的好处
1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销
2.提高响应速度，不用等待创建线程就能立即执行
3.提高线程的可管理性，统一分配、调优和监控
4.防止服务器过载，防止内存溢出或者CPU耗尽

#### 简单工厂 工厂方法 抽象工厂
 * 简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择
 * 工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.
 * 抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.

#### 对象引用的类型
 * Reference(or named Strong Reference)（ 强引用）：普通类型的引用。
 * SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。
 * WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）
 * PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。

#### 五层协议的网络体系结构
1. 物理层，物理层任务是透明传输比特流。
2. 数据链路层，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上透明的传输帧中的数据，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）
3. 网络层，把运输层产生的报文段封装成分组或包进行传送
4. 运输层，负责向两个主机中进程之间的通信提供服务，运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。
5. 应用层，直接为用户的应用进程提供服务。

title: java面试问题总结
date: 2016-04-16 12:09:00
categories: [java,面试]
tags: [java,面试]
---
#### java锁类型
 - 自旋锁，为解决由用户态和内核态的频繁切换以及线程上下文切换开销比较大引入自旋锁。问题：ABA,单核无效。解决：AtomicStampedReference将更新一个“对象 —-引用”二元组，通过在引用上加上“版本号”，从而避免ABA问题。
 - 可重入锁，可重入锁，也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数仍然有获取该锁的代码，但不受影响。
在JAVA环境下 ReentrantLock 和synchronized 都是 可重入锁。可重入锁最大的作用是避免死锁。
 - 阻塞锁，能够进入\退出、阻塞状态或包含阻塞锁的方法有 ，synchronized 关键字，ReentrantLock，Object.wait()\notify(),LockSupport.park()/unpark()。阻塞锁的优势在于，阻塞的线程不会占用cpu时间， 不会导致 CPU占用率过高，但进入时间以及恢复时间都要比自旋锁略慢。

#### java内存模型
(主内存、工作内存、交互、八种操作lock,unlock、重排序三类)
1. 从主存复制变量到当前工作内存 (read and load)
2. 执行代码，改变共享变量 (use and assign)
3. 用工作内存数据刷新主存相关的内容 (store and write)

#### 进程线程管程区别
 - 进程 ：一个程序在一个数据集合上的一次运行过程，是资源分配的最小单位，进程无法突破进程边界存取其他进程内的存储空间
 - 线程 ：线程是进程中的一个实体，是被系统独立调度和执行的最小单位，同一进程所产生的线程共享同一内存空间。

#### 死锁
产生死锁的条件：互斥、请求与保持、不剥夺条件、循环等待条件
*解除与预防*
1.采用资源静态分配策略，破坏”部分分配”条件
2.允许进程剥夺使用其他进程占有的资源，破坏不可剥夺条件
3.采用资源有序分配法，破坏环路条件

#### 聚集索引和非聚集索引
1.聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与物理顺序无关。
2.一个表只能包含一个聚集索引，可以有多个非聚集索引
3.聚集索引对于那些经常要搜索范围值的列有效。使用聚集索引找到包含第一个值的行后，便可以确保包含后续索引值的行在物理相邻
4.非索引存储中的项目按索引键值的顺序存储，而表中信息按另一种顺序存储。

#### 单例模式
1.为避免其他程序创建该类对象，将构造函数私有化
2.为了其他程序访问到该类对象，须在本类中创建一个该类私有对象
3.为了方便其他程序访问该类对象，可对外提供一个公共访问方式
比如API中的Runtime类就是单例设计模式。
```
class Singleton{
	private static Singleton instance;
	private static byte[] lock = new byte[1];
	private Singleton{ }
	public static Singleton getInstance(){
		if(instance == null){
			synchronized(lock){
				if(instance == null) {
					instance = new Singleton();
				}
			}
		}
		return instance;
	}
}
```
#### 单例适用场景
控制资源的使用，通过线程同步来控制资源的并发访问
控制实例的产生，以达到节约资源的目的
控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信

#### final关键字
1. final修饰变量：final修饰的变量只能被赋值一次，可以是在声明的时候进行初始化，也可以是在初始化函数中进行初始化，基本数据类型在赋值后它的值无法改变，如果是一个对象的引用则不能再指向其它对象，但是这个对象的值是可以改变的。比如一个指向StringBuilder的对象A，A不能再被赋值，但是这个StringBuilder对象的值是可以改变的。
2. final修饰的方法：final修饰的方法不能被子类重写
3. final修饰的类：final修饰的类不能被继承，也就是说它所有的实现都不能被改变，方法不能被重写。常用于设计一些不想让使用者改变的类。

#### fail-fast && fail-safe
Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。我们知道java.util.HashMap不是线程安全的，因此如果在使用迭代器的过程中有其他线程修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。这一策略在源码中的实现是通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，那么在迭代器初始化过程中会将这个值赋给迭代器的expectedModCount。在迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他线程修改了Map：
注意到modCount声明为volatile，保证线程之间修改的可见性。

#### 堆内存
 * 新生代，新生区是类的诞生、成长、消亡的区域，一个类在这里产生、应用，最后被垃圾回收器收集，结束生命。新生区又分为两部分：伊甸区和幸存者区，所有的类都是在伊甸区被创建的，幸存区有两个：0区（Survivor 0）和1区(Survivor 1)。当伊甸区的空间用完，程序又需要创建对象，JVM的垃圾回收器将对伊甸区进行垃圾回收，将伊甸区中的不再被其他对象所引用的对象进行销毁。然后将伊甸区中的剩余对象移动到幸存0区，若幸存0区也满了，再对该区进行垃圾回收，然后移动到1区，如果1区也满了，就移动到老年区。
 * 老年代，用于保存从新生区筛选出来的java对象，一般池对象都在这个区域活跃。
 * 永久代 永久存储区是一个常驻内存区域，用于存放JDK自身所携带的Class Interface 的元数据，也就是说，它存储的是运行环境必须的类信息，被装载进此区域的数据是不会被回收器回收的，关闭JVM才会释放此区域所占用的内存。

#### 垃圾收集算法
 * 标记-清除算法
首先标记出所有需要回收的对象，在标完成后统一回收掉所有被标记的对象。缺点：效率不高，且标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致运行过程中需要分配大对象的时候无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
 * 复制算法
将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次清理掉，内存使用率不高，现在商业虚拟机比如HotSpot都采用8:1的比例（Eden:Survivor）
 * 标记-整理算法
把存活对象往内存的一端移动，然后直接回收边界以外的内存，提高了内存利用率，适合在收集对象存活时间较长的老年代。
 * 分代收集算法
根据对象的存活时间把内存分为新生代和老年代，根据各代对象的存活特点，每个代采用不同的垃圾回收算法，新生代采用标记-复制算法，老年代采用标记-整理算法。

#### transient
transient变量不会进行序列化。例如一个实现Serializable接口的类在序列化到ObjectStream的时候，transient类型的变量不会被写入流中，同时，反序列化回来的时候，对应变量的值为null。

#### 重写equals方法
1.使用==符号检查“参数是否为这个对象的引用”。如果是，则返回true。这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做。
2.使用instanceof操作符检查“参数是否为正确的类型”。如果不是，则返回false。一般来说，所谓“正确的类型”是指equals方法所在的那个类。
3.把参数转换成正确的类型。因为转换之前进行过instanceof测试，所以确保会成功。
4.对于该类中的每个“关键”域，检查参数中的域是否与该对象中对应的域相匹配。如果这些测试全部成功，则返回true;否则返回false。
5.当编写完成了equals方法之后，检查“对称性”、“传递性”、“一致性”。

#### 重写hashCode的意义
1. 在每个覆盖了equals方法的类中，也必须覆盖hashCode方法。如果不这样做的话，就会违反hashCode的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括HashMap、HashSet和Hashtable。
2. 在应用程序的执行期间，只要对象的equals方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。
3. 如果两个对象根据equals()方法比较是相等的，那么调用这两个对象中任意一个对象的hashCode方法都必须产生同样的整数结果。
4. 如果两个对象根据equals()方法比较是不相等的，那么调用这两个对象中任意一个对象的hashCode方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。

#### JVM 运行时数据区 (JVM Runtime Area)
6个区域：
1、PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。
2、java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈
帧在虚拟机栈中从入栈到出栈的过程。
3、本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。
4、Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。
Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。
JVM将Heap分为两块：新生代New Generation和旧生代Old Generation
** 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因 **
5、方法区
方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。
方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。
6、运行时常量池其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。

#### 线程池的好处
1.降低资源消耗，重用已经创建好的线程，降低创建和销毁的开销
2.提高响应速度，不用等待创建线程就能立即执行
3.提高线程的可管理性，统一分配、调优和监控
4.防止服务器过载，防止内存溢出或者CPU耗尽

#### 简单工厂 工厂方法 抽象工厂
 * 简单工厂: 抽象了同一类型(比如不同品牌的笔记本电脑)产品的生产过程,通过工厂类来实现对不同产品生产过程的选择
 * 工厂方法: 不仅抽象了产品类的生产过程,还抽象了工厂类本身. 将特定的产品的生产过程和特定的工厂相对应. 将原先工厂类中的选择提升到工程类以上的层级—即客户层级. 通过选择特定的工厂,来选择生产特定的产品.
 * 抽象工厂: 在工厂方法的基础上,将特定的产品生产过程和特定的工厂类之间的对应关系解除,使得工厂类和产品类之间能够产生更多灵活的组合方式.

#### 对象引用的类型
 * Reference(or named Strong Reference)（ 强引用）：普通类型的引用。
 * SoftReference（ 软引用）：被这种引用指向的对象，如果此对象没要再被其他Strong Reference引用的话，可能在任何时候被GC。虽然是可能在任何时候被GC，但是通常是在可用内存数比较低的时候，并且在程序抛出OutOfMemoryError之前才发生对此对象的GC。SoftReference通常被用作实现Cache的对象引用，如果这个对象被GC了，那么他可以在任何时候再重新被创建。另外，根据JDK文档中介绍，实际JVM的实现是鼓励不回收最近创建和最近使用的对象。SoftReference 类的一个典型用途就是用于内存敏感的高速缓存。
 * WeakReference（弱引用）：如果一个被WeakReference引用的对象，当没要任何SoftReference和StrongReference引用时，立即会被GC。和SoftReference的区别是：WeakReference对象是被eagerly collected，即一旦没要任何SoftReference和StrongReference引用，立即被清楚；而只被SoftReference引用的对象，不回立即被清楚，只有当内存不够，即将发生OutOfMemoryError时才被清除，而且是先清除不常用的。SoftReference适合实现Cache用。WeakReference 类的一个典型用途就是规范化映射（ canonicalized mapping ）
 * PhantomReference（虚引用）：当没有StrongReference，SoftReference和WeakReference引用时，随时可被GC。通常和ReferenceQueue联合使用，管理和清除与被引用对象（没有finalize方法）相关的本地资源。

#### 五层协议的网络体系结构
1. 物理层，物理层任务是透明传输比特流。
2. 数据链路层，将网络层交下来的IP数据包组装成帧，在两个相邻节点间的链路上透明的传输帧中的数据，每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）
3. 网络层，把运输层产生的报文段封装成分组或包进行传送
4. 运输层，负责向两个主机中进程之间的通信提供服务，运输层有复用和分用的功能。复用就是多个应用层进程可同时使用下面运输层的服务，分用则是运输层把收到的信息分别交付上面应用层中的相应进程。
5. 应用层，直接为用户的应用进程提供服务。

#### SQL优化
1. select 尽量少用*，只查询需要的列
2. 多表连接时使用别名，提高sql解释效率，减少重名错误
3. where中把限制条件最大的放前面，利用数据库查询优化器优化
4. 时分秒不必要时，选择Date类型而不是DateTime类型
5. >=比>更容易定位索引
6. like "R%"使用索引，like "%R"不使用索引
7. 在where中尽量使用被索引的列

#### SQL和NoSQL区别
> * 非关系型数据库的优势：
1. 性能
NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。
2. 可扩展性
同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。
> * 关系型数据库的优势：
1. 复杂查询
可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。
2. 事务支持
使得对于安全性能很高的数据访问要求得以实现。

#### Cookie && Session

#### Get && Post

#### 事务的四个特点ACID:
A:原子性：事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。它是一个整体，不能再拆分
C：一致性：事务在完成时，必须使所有的数据都保持一致状态。。某种程度的一致
I:隔离性：事务中隔离，每一个事务是单独的请求将单独的处理，与其它事务没有关系，互不影响
D：持久性：如果事务一旦提交，就对数据的修改永久保留

#### 接口和抽象类的区别是什么？
1. 接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
2. 类可以实现很多个接口，但是只能继承一个抽象类
3. 类如果要实现一个接口，它必须要实现接口声明的所有方法。但是，类可以不4. 实现抽象类声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
5. 抽象类可以在不提供接口方法实现的情况下实现接口。
6. Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
7. Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。





